## This is a skeleton of what our code will eventually look like.
## We can fill in pieces as we develop, write, and test them.

#### NOTATION:
# Y = salary midpoint
# K = number of "brackets" for Y
# k = referring to the kth bracket, out of K total
# Kmax = the maximum K we will try
# X(K) = set of protowords, as a function of K. Remember that if we have J
#        protowords for each bracket, then we will have K*J predictors in this set.
# Z = set of other features such as posting length.
# X'(K) = X(K) U Z


#### STEPS:
# 1. Split sample and reserve test data.
# 2. Use exploratory/graphical methods to determine Kmax
# 3. For each K in 2:Kmax
#		Derive the set of protowords for each class k as a function of K
# 4. Come up with appropriate specifications for each of our models:
#	a. Regression
#	b. Ordinal GLM
#	c. Probability model
#	d. Decision tree
# 5. For every K, fit each model
# 6. For every model and every K, compute a variety of diagnostics:
#	a. Some indicator of predictive accuracy... (MAE, MAPE, MSE?)
#	b  i. Average log predictive density
#	b ii. K-L distance of test data to posterior predictive
#	c. Bayes factor

predictive_accuracy = function( k , model ){
	# percentage-based?

}

plot_over_k = function( diagnostic_function ){
	# diagnostic_function is some function of a model that is parameterized k
	for (k in 1:K){
		plot( x=k , y= diagnostic_function(k) )
	}
}
